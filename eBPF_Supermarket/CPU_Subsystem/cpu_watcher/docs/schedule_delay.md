## schedule_delay工具介绍

​	schedule_delay工具可以检测该系统当前的调度延迟。即从一个任务具备运行的条件，到真正执行（获得 CPU 的执行权）的这段时间。

​	实时观测该指标可以帮助我们了解到当前操作系统的负载。

### 原理分析

​	只需考虑，在何时一个任务会被加入运行队列等待运行。内核提供了两个函数实现这个功能：

- 新建的进程通过调用`wake_up_new_task`，将新创建的任务加入runqueue等待调度。
- 进程从睡眠状态被唤醒时触发，调用`ttwu_do_wakeup`函数，进入runqueue等待调度。

​	关于这两个函数，内核提供了两个对应的`tracepoint`：

|     内核函数     |    对应`tracepoint`    |
| :--------------: | :--------------------: |
| wake_up_new_task | sched:sched_wakeup_new |
|  ttwu_do_wakeup  |   sched:sched_wakeup   |

​	在触发到这两个tracepoint的时候，记录这个进程的信息和进入运行队列的时间。

​	除此之外，我们还应该考虑到，当一个进程**被迫离开cpu**时，其状态依然是`TASK_RUNNING`，所以在schedule时，我们还要做出判断，决定该进程是否要被记录。

| 内核函数 |  对应`tracepoint`  |
| :------: | :----------------: |
| schedule | sched:sched_switch |

​	在触发到这个tracepoint时，记录此时即将要占用cpu的进程信息，通过ebpf map记录的进入运行队列的时间作差，即调度延迟。在这里还需要判断上一个进程是否要被记录。

```c
  if(prev_state == TASK_RUNNING)//判断退出cpu进程的状态
```

​	最后要注意的是，为了避免map溢出，我们还需要在进程退出的时候，删除map中记录的数据。

| 内核函数 |     对应`tracepoint`     |
| :------: | :----------------------: |
| do_exit  | sched:sched_process_exit |

### 输出效果

​	我们可以检测到系统从加载ebpf程序到当前的平均、最大、最小调度时延：

```
 TIME    avg_delay/μs     max_delay/μs     min_delay/μs
17:31:28  35.005000       97.663000         9.399000        
17:31:29  326.518000      12618.465000      7.994000        
17:31:30  455.837000      217053.545000     6.462000        
17:31:31  422.582000      217053.545000     6.462000        
17:31:32  382.627000      217053.545000     6.462000        
17:31:33  360.499000      217053.545000     6.462000        
17:31:34  364.805000      217053.545000     6.462000        
17:31:35  362.039000      217053.545000     6.462000        
17:31:36  373.751000      217053.545000     6.462000
```

